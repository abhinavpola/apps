{"0": "```python\ndef max_accordion_length(s):\n    n = len(s)\n    left_bracket = -1\n    right_bracket = -1\n    colon_count = 0\n    max_length = -1\n    \n    # Step 1: Find the first opening bracket '['\n    for i in range(n):\n        if s[i] == '[':\n            left_bracket = i\n            break\n            \n    # If no opening bracket, return -1\n    if left_bracket == -1:\n        return -1\n\n    # Step 2: Find the last closing bracket ']' after the first opening bracket\n    for i in range(n-1, -1, -1):\n        if s[i] == ']':\n            right_bracket = i\n            break\n            \n    # If no closing bracket, return -1\n    if right_bracket == -1 or right_bracket <= left_bracket:\n        return -1\n\n    # Step 3: Count colons and vertical lines between the brackets\n    for i in range(left_bracket + 1, right_bracket):\n        if s[i] == ':':\n            colon_count += 1\n\n    # We need at least two colons\n    if colon_count < 2:\n        return -1\n    \n    # Step 4: Calculate vertical lines\n    vertical_count = 0\n    for i in range(left_bracket + 1, right_bracket):\n        if s[i] == '|':\n            vertical_count += 1\n            \n    # The maximum length of accordion is defined by:\n    # 1 opening bracket + 2 colons + vertical lines + 1 closing bracket\n    max_length = 2 + vertical_count + 2\n    \n    return max_length\n\n# Example usage\ns = input().strip()\nprint(max_accordion_length(s))\n```", "1": "```python\ndef max_digit_sum(x):\n    str_x = str(x)\n    n = len(str_x)\n\n    # Initialize max_sum and result\n    max_sum = sum(int(d) for d in str_x)\n    result = x\n\n    # Check numbers formed by changing digits to 9\n    for i in range(n):\n        if str_x[i] == '0': \n            continue\n        \n        # Create a number with the first i digits of str_x and make the rest 9\n        modified_number = int(str_x[:i] + str(int(str_x[i]) - 1) + '9' * (n - i - 1))\n        if modified_number > x: \n            continue\n\n        # Calculate the sum of digits of the modified number\n        current_sum = sum(int(d) for d in str(modified_number))\n        \n        # Update max_sum and result if the current_sum is greater\n        if current_sum > max_sum or (current_sum == max_sum and modified_number > result):\n            max_sum = current_sum\n            result = modified_number\n\n    print(result)\n\nx = int(input().strip())\nmax_digit_sum(x)\n```", "2": "```python\nn = int(input())\n\ndef is_lucky(year):\n    non_zero_count = sum(1 for digit in str(year) if digit != '0')\n    return non_zero_count <= 1\n\nnext_year = n + 1\nwhile not is_lucky(next_year):\n    next_year += 1\n\nprint(next_year - n)\n```", "3": "```python\nn, q = map(int, input().split())\npainters = [tuple(map(int, input().split())) for _ in range(q)]\n\ndef painted_sections(painters):\n    painted = [0] * (n + 1)\n    for l, r in painters:\n        for i in range(l, r + 1):\n            painted[i] = 1\n    return sum(painted)\n\nmax_painted = 0\n\nfor i in range(q):\n    selected_painters = painters[:i] + painters[i + 1:]\n    max_painted = max(max_painted, painted_sections(selected_painters))\n\nfor i in range(q):\n    for j in range(i + 1, q):\n        selected_painters = [painters[k] for k in range(q) if k != i and k != j]\n        max_painted = max(max_painted, painted_sections(selected_painters))\n\nprint(max_painted)\n```", "4": "```python\nx = int(input())\nhh, mm = map(int, input().split())\n\ndef has_seven(hh, mm):\n    return '7' in f\"{hh:02d}{mm:02d}\"\n\ny = 0\nwhile not has_seven(hh, mm):\n    mm -= x\n    if mm < 0:\n        mm += 60\n        hh -= 1\n        if hh < 0:\n            hh += 24\n    y += 1\n\nprint(y)\n```", "5": "```python\nn, pos, l, r = map(int, input().split())\n\n# If all tabs are within the segment [l, r], no action needed\nif l <= pos <= r:\n    # Calculate how many taps to close to the left\n    left_steps = pos - l\n    # Calculate how many taps to close to the right\n    right_steps = r - pos\n    # Total steps needed to close\n    total_steps = left_steps + right_steps\nelse:\n    total_steps = 0\n    \n# Close tabs to the left of l if necessary\nif pos > r:\n    total_steps += (pos - r) + 1  # Move to r and close to the right\n    total_steps += (l - (r + 1))  # Close all to the left of l\nelif pos < l:\n    total_steps += (l - pos) + 1  # Move to l and close to the left\n    total_steps += ((n - r) + (l - 1))  # Close all to the right of r\n\nprint(total_steps)\n```", "6": "```python\ndef min_blows_to_defeat(t, queries):\n    results = []\n    for i in range(t):\n        n, x = queries[i][:2]\n        blows = queries[i][2:]\n        \n        min_steps = float('inf')\n        can_defeat = False\n        \n        for d, h in blows:\n            effective_damage = min(d, x)\n            if effective_damage == d:\n                # If we can reduce to 0 or below\n                min_steps = min(min_steps, (x + d - 1) // d)  # ceil(x / d)\n                can_defeat = True\n            else:\n                # If not, calculate the effective net change in heads\n                net_change = effective_damage - h\n                if net_change < 0:\n                    # If even the maximum blow can't keep heads from growing\n                    continue\n                # Calculate the steps needed in this scenario\n                steps = 0\n                current_heads = x\n                while current_heads > 0:\n                    current_heads -= effective_damage\n                    steps += 1\n                    if current_heads > 0:\n                        current_heads += h\n                min_steps = min(min_steps, steps)\n        \n        if can_defeat and min_steps != float('inf'):\n            results.append(min_steps)\n        else:\n            results.append(-1)\n    \n    return results\n\n# Input parsing\nt = int(input().strip())\nqueries = []\nfor _ in range(t):\n    n, x = map(int, input().strip().split())\n    blows = [tuple(map(int, input().strip().split())) for __ in range(n)]\n    queries.append((n, x) + tuple(blows))\n\n# Get results\nresults = min_blows_to_defeat(t, queries)\n\n# Output results\nfor res in results:\n    print(res)\n```", "7": "```python\nn, m = map(int, input().split())\n\nday = 0\nwhile n > 0:\n    day += 1\n    n = min(n + m, n)  # Add grains, but can't exceed capacity\n    n -= day  # Sparrows eat grains\nprint(day)\n```", "8": "```python\ndef is_koutsu(tiles):\n    return len(set(tiles)) == 1\n\ndef is_shuntsu(tiles):\n    suits = {}\n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        if suit not in suits:\n            suits[suit] = []\n        suits[suit].append(number)\n\n    for numbers in suits.values():\n        numbers.sort()\n        for i in range(len(numbers) - 2):\n            if numbers[i] + 1 == numbers[i + 1] and numbers[i] + 2 == numbers[i + 2]:\n                return True\n    return False\n\ntiles = input().strip().split()\n\nif is_koutsu(tiles) or is_shuntsu(tiles):\n    print(0)\nelse:\n    counts = {tile: tiles.count(tile) for tile in set(tiles)}\n\n    options = []\n    for tile in tiles:\n        number = int(tile[0])\n        suit = tile[1]\n        \n        # Check for possibility of forming a shuntsu\n        shuntsu_needed = []\n        if number > 1:\n            shuntsu_needed.append(f\"{number - 1}{suit}\")\n        if number < 9:\n            shuntsu_needed.append(f\"{number + 1}{suit}\")\n        \n        for needed in shuntsu_needed:\n            if needed not in counts:\n                options.append(needed)\n\n    if len(options) > 0:\n        print(1)\n    else:\n        print(2)\n```", "9": "```python\nd = int(input())\nn, m = map(int, input().split())\nsofas = []\n\nfor i in range(d):\n    x1, y1, x2, y2 = map(int, input().split())\n    sofas.append(((min(x1, x2), min(y1, y2)), (max(x1, x2), max(y1, y2))))\n\ncnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\ndef count_relatives(sofa, sofas):\n    (x1, y1), (x2, y2) = sofa\n    cnt_left = cnt_right = cnt_top = cnt_bottom = 0\n    \n    for i, (s1, s2) in enumerate(sofas):\n        if i == sofas.index(sofa):  # skip counting the same sofa\n            continue\n        if s2[0] == y1 and s2[1] < x1:  # Left\n            cnt_left += 1\n        elif s1[0] == y1 and s1[1] > x2:  # Right\n            cnt_right += 1\n        elif s2[1] == x1 and s2[0] < y1:  # Top\n            cnt_top += 1\n        elif s1[1] == x1 and s1[0] > y2:  # Bottom\n            cnt_bottom += 1\n            \n    return (cnt_left, cnt_right, cnt_top, cnt_bottom)\n\nfor i in range(d):\n    cnt = count_relatives(sofas[i], sofas)\n    if cnt == (cnt_l, cnt_r, cnt_t, cnt_b):\n        print(i + 1)\n        break\nelse:\n    print(-1)\n```"}